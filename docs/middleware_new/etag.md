<!-- Code generated by gomarkdoc. DO NOT EDIT -->

---
id: etag
---


# etag

```go
import "github.com/gofiber/fiber/v3/middleware/etag"
```

## Index

- [Variables](<#variables>)
- [func Generate\(body \[\]byte\) \[\]byte](<#Generate>)
- [func GenerateWeak\(body \[\]byte\) \[\]byte](<#GenerateWeak>)
- [func New\(config ...Config\) fiber.Handler](<#New>)
- [type Config](<#Config>)


## Variables

<a name="ConfigDefault"></a>ConfigDefault is the default config

```go
var ConfigDefault = Config{
    Weak: false,
    Next: nil,
}
```

<a name="Generate"></a>
## func Generate

```go
func Generate(body []byte) []byte
```

Generate returns a strong ETag for body.

<a name="GenerateWeak"></a>
## func GenerateWeak

```go
func GenerateWeak(body []byte) []byte
```

GenerateWeak returns a weak ETag for body.

<a name="New"></a>
## func New

```go
func New(config ...Config) fiber.Handler
```

New creates a new middleware handler

<a name="Config"></a>
## type Config

Config defines the config for middleware.

```go
type Config struct {
    // Next defines a function to skip this middleware when returned true.
    //
    // Optional. Default: nil
    Next func(c fiber.Ctx) bool
    // Weak indicates that a weak validator is used. Weak etags are easy
    // to generate, but are far less useful for comparisons. Strong
    // validators are ideal for comparisons but can be very difficult
    // to generate efficiently. Weak ETag values of two representations
    // of the same resources might be semantically equivalent, but not
    // byte-for-byte identical. This means weak etags prevent caching
    // when byte range requests are used, but strong etags mean range
    // requests can still be cached.
    Weak bool
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
